// frontend/src/lib/pool/engine.ts
/**
 * PoolGameEngine â€” Realistic 8-ball pool physics
 * Based on analysis of 8ball-source and billiards-next implementations
 * 
 * Features:
 * - Accurate ball-ball collision with impulse-based physics
 * - Realistic cushion response with spin transfer
 * - Pocket detection with proper entry mechanics
 * - Advanced spin mechanics (screw, english, side spin)
 * - Proper friction and velocity damping
 */

type GameMode = 'practice' | 'match';
type PlayerId = 'p1' | 'p2';
type TargetGroup = 'ANY' | 'SOLIDS' | 'STRIPES' | '8';

type EngineHud = {
  turn: PlayerId;
  p1Target: TargetGroup;
  p2Target: TargetGroup;
  message: string;
  winner: PlayerId | null;
  foul: boolean;
  shotNumber: number;
  ballInHand: boolean;
  p1Score: number;
  p2Score: number;
  p1BallsRemaining: number;
  p2BallsRemaining: number;
  currentRun: number;
  gameStats: {
    totalShots: number;
    p1ConsecutiveWins: number;
    p2ConsecutiveWins: number;
    longestRun: number;
  };
  shotPower: number;
  shotType: string;
  lastShotResult: string;
};

type EngineOptions = {
  mode: GameMode;
  onHud: (hud: EngineHud) => void;
};

type Pocket = { x: number; y: number; radius: number };

// Vector2 class with all necessary methods
class Vec2 {
  x: number;
  y: number;
  
  constructor(x = 0, y = 0) {
    this.x = x;
    this.y = y;
  }
  
  clone() {
    return new Vec2(this.x, this.y);
  }
  
  add(v: Vec2) {
    this.x += v.x;
    this.y += v.y;
    return this;
  }
  
  sub(v: Vec2) {
    this.x -= v.x;
    this.y -= v.y;
    return this;
  }
  
  scale(s: number) {
    this.x *= s;
    this.y *= s;
    return this;
  }
  
  len() {
    return Math.hypot(this.x, this.y);
  }
  
  lenSq() {
    return this.x * this.x + this.y * this.y;
  }
  
  normalize() {
    const l = this.len();
    if (l > 0.0001) {
      this.x /= l;
      this.y /= l;
    }
    return this;
  }
  
  magnitude() {
    return this.len();
  }
  
  dot(v: Vec2) {
    return this.x * v.x + this.y * v.y;
  }
  
  perp() {
    return new Vec2(-this.y, this.x);
  }
  
  getLeftNormal() {
    return new Vec2(-this.y, this.x);
  }
  
  getRightNormal() {
    return new Vec2(this.y, -this.x);
  }
  
  times(s: number) {
    return new Vec2(this.x * s, this.y * s);
  }
  
  plus(v: Vec2) {
    return new Vec2(this.x + v.x, this.y + v.y);
  }
  
  minus(v: Vec2) {
    return new Vec2(this.x - v.x, this.y - v.y);
  }
  
  static sub(a: Vec2, b: Vec2) {
    return new Vec2(a.x - b.x, a.y - b.y);
  }
  
  static add(a: Vec2, b: Vec2) {
    return new Vec2(a.x + b.x, a.y + b.y);
  }
}

type Ball = {
  id: number;
  pos: Vec2;
  vel: Vec2;
  active: boolean;
  radius: number;
  isCue?: boolean;
  
  // Spin mechanics
  screw?: number;
  english?: number;
  ySpin?: number;
  grip?: number;
  deltaScrew?: { x: number; y: number };
  firstContact?: boolean;
  
  lastCollision: number;
  pocketing?: { pocketIndex: number; startedAt: number; fallDuration: number };
};

type ShotEvents = {
  firstContact: number | null;
  pocketed: number[];
  cushionHits: Set<number>;
  cueScratch: boolean;
};

// Table geometry
const TABLE_WIDTH = 1600;
const TABLE_HEIGHT = 900;
const RAIL_MARGIN = 96;
const POCKET_RADIUS = 70;
const BALL_RADIUS = 32;
const MIN_SHOT_POWER = 100;
const MAX_SHOT_POWER = 2800;

// Physics constants - tuned from 8ball-source
const PHYSICS_TIMESTEP = 1 / 120;
const FRICTION = 750; // deceleration px/s^2  
const BALL_RESTITUTION = 0.95;
const CUSHION_RESTITUTION = 0.85;
const CUSHION_LOSS = 0.96; // tangential velocity retention
const MIN_VELOCITY_CLAMP = 1.0;
const MAX_COLLISION_ITERATIONS = 4;
const POCKET_LIP_RADIUS = POCKET_RADIUS * 0.82;
const POCKET_SUCTION_RADIUS = POCKET_RADIUS * 2.8;
const POCKET_FALL_TIME = 500;
const POSITIONAL_CORRECTION = 0.88;
const POSITIONAL_SLOP = 0.01;

function clamp(v: number, a: number, b: number) {
  return Math.max(a, Math.min(b, v));
}

function nowMs() {
  return typeof performance !== 'undefined' ? performance.now() : Date.now();
}

function groupForBall(id: number): TargetGroup {
  if (id === 8) return '8';
  if (id >= 1 && id <= 7) return 'SOLIDS';
  if (id >= 9 && id <= 15) return 'STRIPES';
  return 'ANY';
}

export class PoolGameEngine {
  private mode: GameMode;
  private onHud: (hud: EngineHud) => void;

  // Canvas & rendering
  private canvas: HTMLCanvasElement | null = null;
  private ctx: CanvasRenderingContext2D | null = null;
  private rafId: number | null = null;
  private dpr = 1;
  private cssWidth = 0;
  private cssHeight = 0;
  private scale = 1;
  private offsetX = 0;
  private offsetY = 0;

  // Simulation state
  private balls: Ball[] = [];
  private pockets: Pocket[] = [];
  private shotEvents: ShotEvents = {
    firstContact: null,
    pocketed: [],
    cushionHits: new Set<number>(),
    cueScratch: false
  };

  private turn: PlayerId = 'p1';
  private p1Target: TargetGroup = 'ANY';
  private p2Target: TargetGroup = 'ANY';
  private shotNumber = 0;
  private shotRunning = false;
  private ballInHand = false;
  private winner: PlayerId | null = null;
  private foul = false;
  private message = 'Break the rack';

  // Control/aim
  private isAiming = false;
  private isPlacingCue = false;
  private aimDir = new Vec2(1, 0);
  private aimPower = 0;

  // AI / debug
  private aiDifficulty: number = 5;
  private debugMode: boolean = false;

  // Audio
  private audioContext: AudioContext | null = null;
  private audioBuffers: Map<string, AudioBuffer> = new Map();
  private soundEnabled = true;

  // Stats
  private p1Score = 0;
  private p2Score = 0;
  private gameStats = {
    totalShots: 0,
    p1ConsecutiveWins: 0,
    p2ConsecutiveWins: 0,
    longestRun: 0,
    currentRun: 0
  };

  // Timing
  private lastTime = 0;
  private accumulator = 0;

  constructor(options: EngineOptions) {
    this.mode = options.mode;
    this.onHud = options.onHud;
    this.setupTableGeometry();
    this.resetRack();
    this.initializeAudio().catch(() => {
      this.soundEnabled = false;
    });
  }

  async loadAssets() {
    return;
  }

  bindCanvas(canvas: HTMLCanvasElement) {
    this.canvas = canvas;
    const ctx = canvas.getContext('2d');
    if (!ctx) throw new Error('Canvas context unavailable');
    this.ctx = ctx;
    this.render();
  }

  resize(width: number, height: number, dpr: number) {
    if (!this.canvas || !this.ctx) return;
    this.dpr = clamp(dpr || window.devicePixelRatio || 1, 1, 3);
    this.cssWidth = width;
    this.cssHeight = height;
    const bufferW = Math.max(1, Math.floor(width * this.dpr));
    const bufferH = Math.max(1, Math.floor(height * this.dpr));
    this.canvas.width = bufferW;
    this.canvas.height = bufferH;
    this.canvas.style.width = `${width}px`;
    this.canvas.style.height = `${height}px`;
    this.ctx.setTransform(this.dpr, 0, 0, this.dpr, 0, 0);

    const sx = (width * 0.96) / TABLE_WIDTH;
    const sy = (height * 0.96) / TABLE_HEIGHT;
    this.scale = Math.min(sx, sy);
    this.offsetX = (width - TABLE_WIDTH * this.scale) / 2;
    this.offsetY = (height - TABLE_HEIGHT * this.scale) / 2;
  }

  start() {
    this.lastTime = nowMs();
    const loop = () => {
      const ms = nowMs();
      const dtReal = Math.min((ms - this.lastTime) / 1000, 0.05);
      this.lastTime = ms;
      this.accumulator += dtReal;
      let steps = 0;
      while (this.accumulator >= PHYSICS_TIMESTEP && steps < 8) {
        this.step(PHYSICS_TIMESTEP);
        this.accumulator -= PHYSICS_TIMESTEP;
        steps++;
      }
      this.render();
      this.rafId = requestAnimationFrame(loop);
    };
    this.rafId = requestAnimationFrame(loop);
  }

  stop() {
    if (this.rafId) {
      cancelAnimationFrame(this.rafId);
      this.rafId = null;
    }
  }

  screenToWorld(clientX: number, clientY: number, rect: DOMRect) {
    const x = (clientX - rect.left - this.offsetX) / this.scale;
    const y = (clientY - rect.top - this.offsetY) / this.scale;
    return { x, y };
  }

  onPointerDown(x: number, y: number) {
    if (this.winner) return;
    if (this.mode === 'practice' && this.turn === 'p2') return;
    const cue = this.balls[0];
    if (!cue) return;

    // Place cue ball if in ball-in-hand mode
    if (this.ballInHand && this.turn === 'p1') {
      this.isPlacingCue = true;
      this.placeCueBall(x, y);
      this.emitHud();
      return;
    }

    // Start aiming if balls are stationary
    if (!this.shotRunning && this.isAllBallsStopped()) {
      this.isAiming = true;
      this.updateAim(x, y);
      this.emitHud();
    }
  }

  onPointerMove(x: number, y: number) {
    if (this.isPlacingCue) {
      this.placeCueBall(x, y);
      this.emitHud();
    }
    if (this.isAiming) {
      this.updateAim(x, y);
      this.emitHud();
    }
  }

  onPointerUp() {
    if (this.isPlacingCue) {
      this.isPlacingCue = false;
      // Keep ballInHand true until shot is taken
      this.emitHud();
      return;
    }
    if (this.isAiming) {
      this.isAiming = false;
      if (this.aimPower > MIN_SHOT_POWER) {
        this.takeShot();
      }
      this.aimPower = 0;
    }
  }

  setAiDifficulty(level: number) {
    this.aiDifficulty = clamp(level, 1, 5);
  }

  setDebugMode(enabled: boolean) {
    this.debugMode = enabled;
  }

  resetGame() {
    this.p1Score = 0;
    this.p2Score = 0;
    this.gameStats.currentRun = 0;
    this.winner = null;
    this.foul = false;
    this.resetRack();
  }

  /* ================ Table & Rack ================ */

  private setupTableGeometry() {
    const left = RAIL_MARGIN;
    const right = TABLE_WIDTH - RAIL_MARGIN;
    const top = RAIL_MARGIN;
    const bottom = TABLE_HEIGHT - RAIL_MARGIN;
    const midX = TABLE_WIDTH / 2;
    
    this.pockets = [
      { x: left, y: top, radius: POCKET_RADIUS },
      { x: midX, y: top, radius: POCKET_RADIUS },
      { x: right, y: top, radius: POCKET_RADIUS },
      { x: left, y: bottom, radius: POCKET_RADIUS },
      { x: midX, y: bottom, radius: POCKET_RADIUS },
      { x: right, y: bottom, radius: POCKET_RADIUS }
    ];
  }

  private resetRack() {
    this.balls = [];
    
    // Cue ball
    const cue: Ball = {
      id: 0,
      pos: new Vec2(TABLE_WIDTH * 0.25, TABLE_HEIGHT / 2),
      vel: new Vec2(),
      active: true,
      radius: BALL_RADIUS,
      isCue: true,
      screw: 0,
      english: 0,
      ySpin: 0,
      grip: 1,
      deltaScrew: { x: 0, y: 0 },
      firstContact: false,
      lastCollision: 0
    };
    this.balls.push(cue);

    // Rack the balls
    const rackX = TABLE_WIDTH * 0.72;
    const rackY = TABLE_HEIGHT / 2;
    const gap = BALL_RADIUS * 2 - 1;
    const order = [1, 9, 2, 10, 8, 3, 11, 4, 12, 5, 13, 6, 14, 7, 15];
    let idx = 0;
    
    for (let row = 0; row < 5; row++) {
      for (let col = 0; col <= row; col++) {
        const x = rackX + row * gap * 0.87;
        const y = rackY - row * gap * 0.5 + col * gap;
        const id = order[idx++]!;
        this.balls.push({
          id,
          pos: new Vec2(x, y),
          vel: new Vec2(),
          active: true,
          radius: BALL_RADIUS,
          isCue: false,
          ySpin: 0,
          grip: 1,
          lastCollision: 0
        });
      }
    }

    this.turn = 'p1';
    this.p1Target = 'ANY';
    this.p2Target = 'ANY';
    this.ballInHand = false;
    this.shotNumber = 0;
    this.shotRunning = false;
    this.winner = null;
    this.foul = false;
    this.message = 'Break the rack';
    this.shotEvents = {
      firstContact: null,
      pocketed: [],
      cushionHits: new Set<number>(),
      cueScratch: false
    };
    this.emitHud();
  }

  /* ================ Physics Simulation ================ */

  private step(dt: number) {
    // Apply deltaScrew effects first (from 8ball-source)
    for (const b of this.balls) {
      if (!b.active) continue;
      if (b.deltaScrew && (Math.abs(b.deltaScrew.x) > 0.1 || Math.abs(b.deltaScrew.y) > 0.1)) {
        b.vel.x += b.deltaScrew.x;
        b.vel.y += b.deltaScrew.y;
        b.deltaScrew.x *= 0.85;
        b.deltaScrew.y *= 0.85;
        if (Math.abs(b.deltaScrew.x) < 0.8 && Math.abs(b.deltaScrew.y) < 0.8) {
          b.deltaScrew = { x: 0, y: 0 };
        }
      }
    }

    // Apply friction
    for (const b of this.balls) {
      if (!b.active) continue;
      const speed = b.vel.len();
      if (speed > 0) {
        const dec = FRICTION * dt;
        const newSpeed = Math.max(0, speed - dec);
        if (newSpeed < MIN_VELOCITY_CLAMP) {
          b.vel.x = 0;
          b.vel.y = 0;
        } else {
          const s = newSpeed / speed;
          b.vel.x *= s;
          b.vel.y *= s;
        }
      }
    }

    // Restore grip gradually
    for (const b of this.balls) {
      if (b.grip !== undefined && b.grip < 1) {
        b.grip += 0.025;
        if (b.grip > 1) b.grip = 1;
      }
    }

    // Decay ySpin
    for (const b of this.balls) {
      if (b.ySpin !== undefined) {
        if (b.ySpin >= 0.15) {
          b.ySpin -= 0.15;
        } else if (b.ySpin <= -0.15) {
          b.ySpin += 0.15;
        } else {
          b.ySpin = 0;
        }
      }
    }

    // Apply curve effect from ySpin
    for (const b of this.balls) {
      if (b.ySpin !== undefined && b.ySpin !== 0) {
        const speed = b.vel.len();
        if (speed > 1) {
          const vel = new Vec2(b.vel.x, b.vel.y);
          const leftNormal = vel.getLeftNormal().normalize();
          const curveForce = leftNormal.times(0.35 * b.ySpin * speed / 800);
          b.vel.x += curveForce.x;
          b.vel.y += curveForce.y;
        }
      }
    }

    // Resolve collisions iteratively
    for (let it = 0; it < MAX_COLLISION_ITERATIONS; it++) {
      for (let i = 0; i < this.balls.length; i++) {
        for (let j = i + 1; j < this.balls.length; j++) {
          this.resolveBallCollision(this.balls[i], this.balls[j]);
        }
      }
    }

    // Integrate positions
    for (const b of this.balls) {
      if (b.active) {
        b.pos.x += b.vel.x * dt;
        b.pos.y += b.vel.y * dt;
      }
    }

    // Handle rails and pockets
    this.handleRailsAndPockets();

    // Check if shot is complete
    if (this.shotRunning && this.isAllBallsStopped()) {
      this.endShot();
    }
  }

  private resolveBallCollision(a: Ball, b: Ball) {
    if (!a.active || !b.active) return;

    const nx = b.pos.x - a.pos.x;
    const ny = b.pos.y - a.pos.y;
    const distSq = nx * nx + ny * ny;
    const r = a.radius + b.radius;
    
    if (distSq === 0 || distSq >= r * r) return;

    const dist = Math.sqrt(distSq);
    const nux = nx / dist;
    const nuy = ny / dist;

    // Positional correction
    const overlap = r - dist;
    const correction = Math.max(overlap - POSITIONAL_SLOP, 0) * POSITIONAL_CORRECTION;
    const half = correction / 2;
    a.pos.x -= nux * half;
    a.pos.y -= nuy * half;
    b.pos.x += nux * half;
    b.pos.y += nuy * half;

    // Relative velocity
    const rvx = b.vel.x - a.vel.x;
    const rvy = b.vel.y - a.vel.y;
    const velAlongNormal = rvx * nux + rvy * nuy;
    
    if (velAlongNormal > 0) return; // separating

    // Record first contact
    if (this.shotEvents.firstContact === null) {
      if (a.id === 0 && b.id !== 0) {
        this.shotEvents.firstContact = b.id;
      } else if (b.id === 0 && a.id !== 0) {
        this.shotEvents.firstContact = a.id;
      }
    }

    // Use 8ball-source collision resolution
    const normal = new Vec2(nux, nuy);
    const tangent = normal.getRightNormal();

    const aVel = new Vec2(a.vel.x, a.vel.y);
    const bVel = new Vec2(b.vel.x, b.vel.y);

    const aNormal = normal.times(aVel.dot(normal));
    const aTangent = tangent.times(aVel.dot(tangent));
    const bNormal = normal.times(bVel.dot(normal));
    const bTangent = tangent.times(bVel.dot(tangent));

    // Spin transfer
    if (a.isCue && Math.abs(b.ySpin ?? 0) < Math.abs(a.ySpin ?? 0)) {
      b.ySpin = -0.5 * (a.ySpin ?? 0);
    }
    if (b.isCue && Math.abs(a.ySpin ?? 0) < Math.abs(b.ySpin ?? 0)) {
      a.ySpin = -0.5 * (b.ySpin ?? 0);
    }

    // Screw effect on first contact
    if (a.isCue && !a.firstContact && a.screw !== undefined) {
      a.deltaScrew = {
        x: aNormal.x * 0.17 * -a.screw,
        y: aNormal.y * 0.17 * -a.screw
      };
      a.firstContact = true;
    }
    if (b.isCue && !b.firstContact && b.screw !== undefined) {
      b.deltaScrew = {
        x: -bNormal.x * 0.17 * -b.screw,
        y: -bNormal.y * 0.17 * -b.screw
      };
      b.firstContact = true;
    }

    // Exchange normal components with restitution
    const newANormal = bNormal.times(BALL_RESTITUTION).plus(aNormal.times(1 - BALL_RESTITUTION));
    const newBNormal = aNormal.times(BALL_RESTITUTION).plus(bNormal.times(1 - BALL_RESTITUTION));

    const newAVel = aTangent.plus(newANormal).times(1.02);
    const newBVel = bTangent.plus(newBNormal).times(1.02);

    a.vel.x = newAVel.x;
    a.vel.y = newAVel.y;
    b.vel.x = newBVel.x;
    b.vel.y = newBVel.y;

    // Reset grip on hard collisions
    if (newBVel.len() > 350) {
      b.grip = 0;
    }

    // Play sound
    const impact = Math.abs(velAlongNormal);
    if (impact > 50) {
      this.playSound('ballHit', clamp(impact / 6000, 0.1, 1.0));
    }

    a.lastCollision = nowMs();
    b.lastCollision = nowMs();
  }

  private handleRailsAndPockets() {
    const bounds = this.playBounds();

    for (const b of this.balls) {
      if (!b.active || b.pocketing) continue;

      // Check pocket capture
      let pocketCaptured = -1;
      for (let pIndex = 0; pIndex < this.pockets.length; pIndex++) {
        const pk = this.pockets[pIndex];
        const dx = pk.x - b.pos.x;
        const dy = pk.y - b.pos.y;
        const d = Math.hypot(dx, dy);

        // Pocket entry
        if (d <= POCKET_LIP_RADIUS) {
          pocketCaptured = pIndex;
          break;
        }

        // Pocket suction
        if (d < POCKET_SUCTION_RADIUS && d > POCKET_LIP_RADIUS) {
          const speed = b.vel.len();
          if (speed > 10) {
            const approachX = dx / d;
            const approachY = dy / d;
            const dot = (b.vel.x * approachX + b.vel.y * approachY) / speed;
            if (dot > 0.3) {
              const suction = (1 - (d - POCKET_LIP_RADIUS) / (POCKET_SUCTION_RADIUS - POCKET_LIP_RADIUS)) * 25;
              b.vel.x += approachX * suction * (1 / 60);
              b.vel.y += approachY * suction * (1 / 60);
            }
          }
        }
      }

      if (pocketCaptured >= 0) {
        b.pocketing = {
          pocketIndex: pocketCaptured,
          startedAt: nowMs(),
          fallDuration: POCKET_FALL_TIME
        };
        b.active = false;
        if (b.id === 0) {
          this.shotEvents.cueScratch = true;
        } else {
          this.shotEvents.pocketed.push(b.id);
        }
        this.playSound('pocketHit', clamp(b.vel.len() / 3000, 0.3, 1.0));
        continue;
      }

      // Cushion collisions
      const leftHit = b.pos.x - b.radius <= bounds.left;
      const rightHit = b.pos.x + b.radius >= bounds.right;
      const topHit = b.pos.y - b.radius <= bounds.top;
      const bottomHit = b.pos.y + b.radius >= bounds.bottom;

      if (leftHit && !this.isNearPocket(b.pos, [0, 3])) {
        b.pos.x = bounds.left + b.radius;
        this.resolveCushionCollision(b, new Vec2(1, 0));
      } else if (rightHit && !this.isNearPocket(b.pos, [2, 5])) {
        b.pos.x = bounds.right - b.radius;
        this.resolveCushionCollision(b, new Vec2(-1, 0));
      }

      if (topHit && !this.isNearPocket(b.pos, [0, 1, 2])) {
        b.pos.y = bounds.top + b.radius;
        this.resolveCushionCollision(b, new Vec2(0, 1));
      } else if (bottomHit && !this.isNearPocket(b.pos, [3, 4, 5])) {
        b.pos.y = bounds.bottom - b.radius;
        this.resolveCushionCollision(b, new Vec2(0, -1));
      }
    }
  }

  private isNearPocket(pos: Vec2, pocketIndices: number[]): boolean {
    for (const idx of pocketIndices) {
      const pk = this.pockets[idx];
      const d = Math.hypot(pk.x - pos.x, pk.y - pos.y);
      if (d < POCKET_SUCTION_RADIUS * 0.85) {
        return true;
      }
    }
    return false;
  }

  private resolveCushionCollision(ball: Ball, normal: Vec2) {
    const tangent = normal.perp();

    // Decompose velocity
    const vNormal = normal.times(ball.vel.dot(normal));
    const vTangent = tangent.times(ball.vel.dot(tangent));

    // Apply english effect for cue ball
    if (ball.isCue && ball.english !== undefined && Math.abs(ball.english) > 0.05) {
      const speed = ball.vel.len();
      vTangent.x += tangent.x * 0.2 * ball.english * speed;
      vTangent.y += tangent.y * 0.2 * ball.english * speed;
      ball.english *= 0.5;
      if (Math.abs(ball.english) < 0.1) ball.english = 0;
    }

    // Update ySpin from tangential velocity
    if (ball.ySpin !== undefined) {
      const tangentSpeed = vTangent.len();
      ball.ySpin += -tangentSpeed / 100;
      ball.ySpin = clamp(ball.ySpin, -50, 50);
    }

    // Decay deltaScrew on cushion hit
    if (ball.deltaScrew) {
      ball.deltaScrew.x *= 0.85;
      ball.deltaScrew.y *= 0.85;
    }

    // Reflect with restitution and loss
    ball.vel.x = -vNormal.x * CUSHION_RESTITUTION + vTangent.x * CUSHION_LOSS;
    ball.vel.y = -vNormal.y * CUSHION_RESTITUTION + vTangent.y * CUSHION_LOSS;

    // Amplify slightly (from 8ball-source)
    ball.vel.x *= 1.05;
    ball.vel.y *= 1.05;

    // Reset grip
    if (Math.abs(vNormal.len()) > 600) {
      ball.grip = 0;
    }

    this.shotEvents.cushionHits.add(ball.id);

    const impact = Math.abs(vNormal.len());
    if (impact > 80) {
      this.playSound('cushionHit', clamp(impact / 3500, 0.1, 1.0));
    }
  }

  private isAllBallsStopped(): boolean {
    for (const b of this.balls) {
      if (b.active && b.vel.len() > 1.5) {
        return false;
      }
    }
    return true;
  }

  private endShot() {
    this.shotRunning = false;
    this.evaluateShot();
  }

  /* ================ Game Rules ================ */

  private evaluateShot() {
    const events = this.shotEvents;
    const currentPlayer = this.turn;
    const opponent: PlayerId = currentPlayer === 'p1' ? 'p2' : 'p1';
    const playerTarget = currentPlayer === 'p1' ? this.p1Target : this.p2Target;

    let foul = false;
    let message = '';
    let continueTurn = false;

    this.gameStats.totalShots++;

    // Check fouls
    if (events.firstContact === null && events.pocketed.length === 0) {
      foul = true;
      message = 'No ball contacted';
    }
    if (events.cueScratch) {
      foul = true;
      message = 'Cue ball scratched';
    }

    // Assign groups if needed
    if (!foul && playerTarget === 'ANY' && events.pocketed.length > 0) {
      const solids = events.pocketed.filter(id => id >= 1 && id <= 7);
      const stripes = events.pocketed.filter(id => id >= 9 && id <= 15);
      
      if (solids.length > 0 && stripes.length === 0) {
        this.assignGroups('SOLIDS');
        message = `${currentPlayer === 'p1' ? 'You' : 'Opponent'} assigned SOLIDS`;
      } else if (stripes.length > 0 && solids.length === 0) {
        this.assignGroups('STRIPES');
        message = `${currentPlayer === 'p1' ? 'You' : 'Opponent'} assigned STRIPES`;
      } else if (solids.length > 0 && stripes.length > 0) {
        foul = true;
        message = 'Mixed pocketing - foul';
      }
    }

    // Check legal pocketing
    if (!foul && events.pocketed.length > 0) {
      const legal = this.countLegalBalls(events.pocketed, playerTarget);
      if (legal > 0) {
        continueTurn = true;
        if (currentPlayer === 'p1') {
          this.p1Score += legal;
        } else {
          this.p2Score += legal;
        }
      }
    }

    // Check 8-ball
    if (events.pocketed.includes(8)) {
      const remaining = this.getPlayerBallsRemaining(currentPlayer);
      if (playerTarget === '8' && remaining === 0 && !foul) {
        this.winner = currentPlayer;
        message = `${currentPlayer === 'p1' ? 'You' : 'Opponent'} win!`;
        this.playSound('cheer', 1.0);
      } else {
        this.winner = opponent;
        foul = true;
        message = '8-ball pocketed illegally - opponent wins';
      }
    }

    // Handle turn change
    if (this.winner) {
      this.ballInHand = false;
      this.gameStats.currentRun = 0;
    } else if (foul) {
      this.foul = true;
      this.turn = opponent;
      this.ballInHand = true;
      this.gameStats.currentRun = 0;
    } else if (continueTurn) {
      this.ballInHand = false;
    } else {
      this.turn = opponent;
      this.ballInHand = false;
      this.gameStats.currentRun = 0;
    }

    // Reset shot events
    this.shotEvents = {
      firstContact: null,
      pocketed: [],
      cushionHits: new Set<number>(),
      cueScratch: false
    };

    this.message = message;
    this.emitHud();
  }

  private assignGroups(winnerGets: 'SOLIDS' | 'STRIPES') {
    if (this.turn === 'p1') {
      this.p1Target = winnerGets;
      this.p2Target = winnerGets === 'SOLIDS' ? 'STRIPES' : 'SOLIDS';
    } else {
      this.p2Target = winnerGets;
      this.p1Target = winnerGets === 'SOLIDS' ? 'STRIPES' : 'SOLIDS';
    }
  }

  private countLegalBalls(pocketed: number[], target: TargetGroup) {
    if (target === 'ANY') return 0;
    return pocketed.filter(id => groupForBall(id) === target).length;
  }

  private getPlayerBallsRemaining(player: PlayerId) {
    const target = player === 'p1' ? this.p1Target : this.p2Target;
    if (target === 'SOLIDS') {
      return this.balls.filter(b => b.active && b.id >= 1 && b.id <= 7).length;
    }
    if (target === 'STRIPES') {
      return this.balls.filter(b => b.active && b.id >= 9 && b.id <= 15).length;
    }
    return 0;
  }

  /* ================ Input & Shooting ================ */

  private updateAim(x: number, y: number) {
    const cue = this.balls[0];
    if (!cue) return;
    
    const dir = Vec2.sub(cue.pos, new Vec2(x, y));
    const dist = dir.len();
    if (dist === 0) return;
    
    this.aimDir = dir.clone().normalize();
    const normalized = clamp(dist / 220, 0, 1);
    this.aimPower = MIN_SHOT_POWER + Math.pow(normalized, 1.6) * (MAX_SHOT_POWER - MIN_SHOT_POWER);
  }

  private takeShot() {
    const cue = this.balls[0];
    if (!cue) return;

    // Apply velocity with proper scaling
    const velocityScale = this.aimPower * 0.95;
    cue.vel = this.aimDir.clone().scale(velocityScale);

    // Apply spin
    const spinAmount = Math.min(20, (this.aimPower / MAX_SHOT_POWER) * 18);
    cue.spin = this.aimDir.clone().perp().scale(spinAmount * 0.25);
    cue.ySpin = 0;
    cue.grip = 1;
    cue.firstContact = false;
    cue.deltaScrew = { x: 0, y: 0 };

    this.resumeAudioContext();
    this.playSound('cueHit', clamp(velocityScale / 1000, 0.3, 1));
    
    this.shotRunning = true;
    this.shotNumber++;
    this.ballInHand = false;
    this.emitHud();
  }

  private placeCueBall(x: number, y: number): boolean {
    const bounds = this.playBounds();
    const safeMargin = BALL_RADIUS + 8;
    const pos = new Vec2(
      clamp(x, bounds.left + safeMargin, bounds.right - safeMargin),
      clamp(y, bounds.top + safeMargin, bounds.bottom - safeMargin)
    );

    // Keep away from pockets
    for (const pk of this.pockets) {
      const d = Math.hypot(pk.x - pos.x, pk.y - pos.y);
      if (d < POCKET_LIP_RADIUS * 1.1) {
        const away = Vec2.sub(pos, new Vec2(pk.x, pk.y)).normalize().scale(POCKET_LIP_RADIUS * 1.2);
        pos.x = pk.x + away.x;
        pos.y = pk.y + away.y;
      }
    }

    const cue = this.balls[0];
    
    // Check overlap with other balls
    let canPlace = true;
    for (let i = 1; i < this.balls.length; i++) {
      const b = this.balls[i];
      if (!b.active) continue;
      const d = Math.hypot(b.pos.x - pos.x, b.pos.y - pos.y);
      if (d < BALL_RADIUS * 2.1) {
        canPlace = false;
        break;
      }
    }

    if (canPlace) {
      cue.pos = pos;
      cue.vel.x = 0;
      cue.vel.y = 0;
      cue.ySpin = 0;
      cue.grip = 1;
      cue.deltaScrew = { x: 0, y: 0 };
      return true;
    }
    return false;
  }

  /* ================ Rendering ================ */

  private render() {
    if (!this.ctx || !this.canvas) return;
    const ctx = this.ctx;
    
    ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    ctx.save();
    ctx.translate(this.offsetX, this.offsetY);
    ctx.scale(this.scale, this.scale);

    this.drawTable(ctx);
    for (const pk of this.pockets) this.drawPocket(ctx, pk);
    this.drawRails(ctx);
    
    for (const b of this.balls) {
      if (b.active) {
        this.drawBall(ctx, b);
      } else if (b.pocketing) {
        const elapsed = nowMs() - b.pocketing.startedAt;
        const t = clamp(elapsed / b.pocketing.fallDuration, 0, 1);
        this.drawPocketedBall(ctx, b, t, this.pockets[b.pocketing.pocketIndex]);
      }
    }

    // Draw aim line
    if (this.isAiming && !this.ballInHand) {
      const cue = this.balls[0];
      if (cue) {
        const aimLength = 120 + (this.aimPower / MAX_SHOT_POWER) * 100;
        const ex = cue.pos.x + this.aimDir.x * aimLength;
        const ey = cue.pos.y + this.aimDir.y * aimLength;
        
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.lineWidth = 3;
        ctx.setLineDash([10, 5]);
        ctx.beginPath();
        ctx.moveTo(cue.pos.x, cue.pos.y);
        ctx.lineTo(ex, ey);
        ctx.stroke();
        ctx.setLineDash([]);
      }
    }

    if (this.debugMode) this.drawDebug(ctx);
    ctx.restore();
  }

  private drawTable(ctx: CanvasRenderingContext2D) {
    const w = TABLE_WIDTH;
    const h = TABLE_HEIGHT;
    const grad = ctx.createRadialGradient(w / 2, h / 2, 0, w / 2, h / 2, Math.max(w, h) * 0.7);
    grad.addColorStop(0, '#2b6b32');
    grad.addColorStop(1, '#123a22');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, w, h);
    
    ctx.strokeStyle = 'rgba(0,0,0,0.3)';
    ctx.lineWidth = 6;
    ctx.strokeRect(RAIL_MARGIN - 12, RAIL_MARGIN - 12, w - (RAIL_MARGIN - 12) * 2, h - (RAIL_MARGIN - 12) * 2);
  }

  private drawPocket(ctx: CanvasRenderingContext2D, pk: Pocket) {
    ctx.save();
    ctx.beginPath();
    ctx.fillStyle = '#000';
    ctx.arc(pk.x, pk.y, pk.radius * 0.88, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  private drawRails(ctx: CanvasRenderingContext2D) {
    ctx.save();
    ctx.fillStyle = '#6b3f22';
    ctx.fillRect(0, 0, TABLE_WIDTH, RAIL_MARGIN - 22);
    ctx.fillRect(0, TABLE_HEIGHT - (RAIL_MARGIN - 22), TABLE_WIDTH, RAIL_MARGIN - 22);
    ctx.fillRect(0, 0, RAIL_MARGIN - 22, TABLE_HEIGHT);
    ctx.fillRect(TABLE_WIDTH - (RAIL_MARGIN - 22), 0, RAIL_MARGIN - 22, TABLE_HEIGHT);
    ctx.restore();
  }

  private drawBall(ctx: CanvasRenderingContext2D, b: Ball) {
    const x = b.pos.x;
    const y = b.pos.y;
    const r = b.radius;

    ctx.save();

    // Shadow
    ctx.globalAlpha = 0.3;
    const sg = ctx.createRadialGradient(x + r * 0.2, y + r * 0.9, 0, x + r * 0.2, y + r * 0.9, r * 1.1);
    sg.addColorStop(0, 'rgba(0,0,0,0.5)');
    sg.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = sg;
    ctx.beginPath();
    ctx.ellipse(x + r * 0.25, y + r * 1.05, r * 1.05, r * 0.4, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // Ball body
    const color = this.ballColor(b.id);
    const g = ctx.createRadialGradient(x - r * 0.3, y - r * 0.3, 0, x, y, r * 1.15);
    g.addColorStop(0, this.lighten(color, 35));
    g.addColorStop(0.45, color);
    g.addColorStop(1, this.darken(color, 35));
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.fill();

    // Stripe or number
    if (b.id > 0) {
      if (b.id >= 9) {
        ctx.save();
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.clip();
        ctx.fillStyle = '#fff';
        const stripeHeight = r * 0.8;
        ctx.fillRect(x - r, y - stripeHeight / 2, r * 2, stripeHeight);
        ctx.restore();
      }
      
      ctx.save();
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(x, y - r * 0.08, r * 0.34, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#000';
      ctx.font = `${r * 0.5}px Arial`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(String(b.id), x, y - r * 0.08);
      ctx.restore();
    }

    // Highlight
    ctx.save();
    ctx.globalAlpha = 0.5;
    const hg = ctx.createRadialGradient(x - r * 0.35, y - r * 0.35, 0, x - r * 0.2, y - r * 0.2, r * 0.65);
    hg.addColorStop(0, 'rgba(255,255,255,1)');
    hg.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = hg;
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    ctx.restore();
  }

  private drawPocketedBall(ctx: CanvasRenderingContext2D, b: Ball, t: number, pk: Pocket) {
    const sink = t * (BALL_RADIUS * 0.8);
    const alpha = 1 - t;
    ctx.save();
    ctx.globalAlpha = alpha;
    const x = pk.x;
    const y = pk.y + sink;
    ctx.beginPath();
    ctx.fillStyle = '#0a0a0a';
    ctx.arc(x, y, BALL_RADIUS * (1 - t * 0.5), 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  private drawDebug(ctx: CanvasRenderingContext2D) {
    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,0.3)';
    ctx.lineWidth = 1;
    const b = this.playBounds();
    ctx.strokeRect(b.left, b.top, b.right - b.left, b.bottom - b.top);
    
    for (const pk of this.pockets) {
      ctx.beginPath();
      ctx.strokeStyle = 'rgba(255,0,0,0.5)';
      ctx.arc(pk.x, pk.y, POCKET_LIP_RADIUS, 0, Math.PI * 2);
      ctx.stroke();
      ctx.beginPath();
      ctx.strokeStyle = 'rgba(255,255,0,0.3)';
      ctx.arc(pk.x, pk.y, POCKET_SUCTION_RADIUS, 0, Math.PI * 2);
      ctx.stroke();
    }
    ctx.restore();
  }

  /* ================ Audio ================ */

  private async initializeAudio() {
    try {
      this.audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();
      const sounds = ['ballHit2', 'cushionHit', 'pocketHit', 'cueHit', 'cheer', 'ding'];
      for (const s of sounds) {
        try {
          const resp = await fetch(`/pool/audio/${s}.wav`);
          if (!resp.ok) continue;
          const ab = await resp.arrayBuffer();
          const buf = await this.audioContext.decodeAudioData(ab);
          this.audioBuffers.set(s, buf);
        } catch {
          // ignore
        }
      }
    } catch {
      this.soundEnabled = false;
    }
  }

  private playSound(name: string, volume = 1) {
    if (!this.soundEnabled || !this.audioContext) return;
    const map: Record<string, string> = {
      ballHit: 'ballHit2',
      cushionHit: 'cushionHit',
      pocketHit: 'pocketHit',
      cueHit: 'cueHit',
      cheer: 'cheer',
      ding: 'ding'
    };
    const key = map[name] || name;
    const buf = this.audioBuffers.get(key);
    if (!buf) return;
    try {
      const src = this.audioContext.createBufferSource();
      const gain = this.audioContext.createGain();
      src.buffer = buf;
      src.connect(gain);
      gain.connect(this.audioContext.destination);
      gain.gain.value = clamp(volume, 0, 1);
      src.start();
    } catch {}
  }

  private resumeAudioContext() {
    if (this.audioContext && this.audioContext.state === 'suspended') {
      this.audioContext.resume().catch(() => {});
    }
  }

  /* ================ Helpers ================ */

  private playBounds() {
    return {
      left: RAIL_MARGIN,
      right: TABLE_WIDTH - RAIL_MARGIN,
      top: RAIL_MARGIN,
      bottom: TABLE_HEIGHT - RAIL_MARGIN
    };
  }

  private ballColor(id: number) {
    const solids = [
      '#FFFDF8',
      '#FFD34E',
      '#2563EB',
      '#EF4444',
      '#7C3AED',
      '#FB923C',
      '#10B981',
      '#7F1D1D',
      '#111111'
    ];
    const stripes = [
      '#FFD34E',
      '#2563EB',
      '#EF4444',
      '#7C3AED',
      '#FB923C',
      '#10B981',
      '#7F1D1D'
    ];
    if (id === 0) return solids[0];
    if (id <= 8) return solids[id];
    return stripes[id - 9];
  }

  private lighten(hex: string, amt: number) {
    try {
      const c = hex.replace('#', '');
      const r = clamp(parseInt(c.substr(0, 2), 16) + amt, 0, 255);
      const g = clamp(parseInt(c.substr(2, 2), 16) + amt, 0, 255);
      const b = clamp(parseInt(c.substr(4, 2), 16) + amt, 0, 255);
      return `rgb(${r}, ${g}, ${b})`;
    } catch {
      return hex;
    }
  }

  private darken(hex: string, amt: number) {
    return this.lighten(hex, -amt);
  }

  private emitHud() {
    try {
      this.onHud(this.getHud());
    } catch {}
  }

  getHud(): EngineHud {
    return {
      turn: this.turn,
      p1Target: this.p1Target,
      p2Target: this.p2Target,
      message: this.message,
      winner: this.winner,
      foul: this.foul,
      shotNumber: this.shotNumber,
      ballInHand: this.ballInHand,
      p1Score: this.p1Score,
      p2Score: this.p2Score,
      p1BallsRemaining: this.getPlayerBallsRemaining('p1'),
      p2BallsRemaining: this.getPlayerBallsRemaining('p2'),
      currentRun: this.gameStats.currentRun,
      gameStats: {
        totalShots: this.gameStats.totalShots,
        p1ConsecutiveWins: this.gameStats.p1ConsecutiveWins,
        p2ConsecutiveWins: this.gameStats.p2ConsecutiveWins,
        longestRun: this.gameStats.longestRun
      },
      shotPower: this.aimPower,
      shotType: this.shotNumber === 0 ? 'Break Setup' : 'Play',
      lastShotResult: ''
    };
  }
}
